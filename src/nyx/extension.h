#pragma once

#include <v8.h>
#include <functional>
#include <map>
#include <string>
#include <vector>

#include "nyx/union_bytes.h"

namespace nyx {

class IsolateData;

// BuiltinSourceMap type - maps module IDs to their source bytes
using BuiltinSourceMap = std::map<std::string, UnionBytes>;

// This API allows users of the nyx library to:
// - Register custom C++ internal bindings (accessible via internalBinding())
// - Register custom JavaScript builtins (accessible via require())
//
// Example usage:
//
//   #include <nyx/extension.h>
//   #include <nyx/nyx.h>
//
//   void MyBindingInit(nyx::IsolateData* isolate_data,
//                      v8::Local<v8::ObjectTemplate> target) {
//     // Add methods to target
//   }
//
//   int main() {
//     // Register before Start()
//     nyx::RegisterBinding("my_binding", MyBindingInit);
//     nyx::RegisterBuiltin("my_module", "'use strict'; module.exports = { ... };");
//     return nyx::Start();
//   }

// Callback type for per-isolate binding initialization
// Called once per isolate to set up the binding template
using BindingInitCallback = std::function<void(IsolateData*, v8::Local<v8::ObjectTemplate>)>;

// Callback type for per-context binding initialization (optional)
// Called once per context to perform context-specific setup
using BindingContextCallback = std::function<void(v8::Local<v8::Object>, v8::Local<v8::Context>)>;

// Structure representing an external binding
struct ExternalBinding {
  std::string name;
  BindingInitCallback isolate_init;
  BindingContextCallback context_init;
};

// Structure representing an external JavaScript builtin
struct ExternalBuiltin {
  std::string id;      // Module ID (e.g., "sandbox" or "internal/sandbox/utils")
  std::string source;  // JavaScript source code
};

// Register a custom C++ binding
// The binding will be accessible via internalBinding('name') in JavaScript
void RegisterBinding(const std::string& name,
                     BindingInitCallback isolate_init,
                     BindingContextCallback context_init = nullptr);

// Register a custom JavaScript builtin
// The module will be accessible via require('id') in JavaScript
void RegisterBuiltin(const std::string& id, const std::string& source);

// Register a custom JavaScript builtin from a file path
// The module will be accessible via require('id') in JavaScript
void RegisterBuiltinFromFile(const std::string& id, const std::string& filepath);

// Register a BuiltinSourceMap (generated by js2c --external)
// The source map will be merged into the main builtin loader
// This is more efficient than RegisterBuiltin as it avoids string copying
void RegisterBuiltinSourceMap(const BuiltinSourceMap* source_map);

// Get all registered external bindings
const std::vector<ExternalBinding>& GetExternalBindings();

// Get all registered external builtins (individual registrations)
const std::vector<ExternalBuiltin>& GetExternalBuiltins();

// Get all registered external builtin source maps
const std::vector<const BuiltinSourceMap*>& GetExternalBuiltinSourceMaps();

// Initialize external binding templates (called by CreateInternalBindingTemplates)
void CreateExternalBindingTemplates(IsolateData* isolate_data);

// Cleanup external binding templates (called by ~IsolateData)
void CleanupExternalBindings();

// Find an external binding by name
const ExternalBinding* FindExternalBinding(const std::string& name);

}  // namespace nyx
